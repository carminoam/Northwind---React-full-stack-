{"ast":null,"code":"// Products State - products data needed in the application level:\nexport class ProductsState {\n  constructor() {\n    this.products = [];\n  }\n\n} // Products Action Type - any action which can be done on the above products state:\n\nexport let ProductsActionType; // Products Action - any single object sent to the store during \"dispatch\":\n\n(function (ProductsActionType) {\n  ProductsActionType[\"FetchProducts\"] = \"FetchProducts\";\n  ProductsActionType[\"AddProduct\"] = \"AddProduct\";\n  ProductsActionType[\"UpdateProduct\"] = \"UpdateProduct\";\n  ProductsActionType[\"DeleteProduct\"] = \"DeleteProduct\";\n})(ProductsActionType || (ProductsActionType = {}));\n\n// Products Action Creators - function for creating ProductsAction objects. each function creates one Action object:\nexport function fetchProductsAction(products) {\n  return {\n    type: ProductsActionType.FetchProducts,\n    payload: products\n  };\n}\nexport function addProductAction(product) {\n  return {\n    type: ProductsActionType.AddProduct,\n    payload: product\n  };\n}\nexport function updateProductAction(product) {\n  return {\n    type: ProductsActionType.UpdateProduct,\n    payload: product\n  };\n}\nexport function deleteProductAction(id) {\n  return {\n    type: ProductsActionType.DeleteProduct,\n    payload: id\n  };\n} // Products Reducer - the main function performing any action on products state:\n// the new ProductsState() is a default value for the first time only\n\nexport function productsReducer() {\n  let currentState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ProductsState();\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  // Must duplicate the current state and not touch the given current state: \n  const newState = { ...currentState\n  };\n\n  switch (action.type) {\n    case ProductsActionType.FetchProducts:\n      newState.products = action.payload; // Here the payload is the products list.\n\n      break;\n\n    case ProductsActionType.AddProduct:\n      newState.products.push(action.payload); // Here the payload is a single object to add.\n\n      break;\n\n    case ProductsActionType.UpdateProduct:\n      const indexToUpdate = newState.products.findIndex(p => p.id === action.payload.id); // Here the payload is a single object to update.\n\n      if (indexToUpdate >= 0) {\n        newState.products[indexToUpdate] = action.payload;\n      }\n\n      break;\n\n    case ProductsActionType.DeleteProduct:\n      const indexToDelete = newState.products.findIndex(p => p.id === action.payload); // Here the payload is the id to delete.\n\n      if (indexToDelete >= 0) {\n        newState.products.splice(indexToDelete, 1);\n      }\n\n      break;\n  }\n\n  return newState;\n}","map":{"version":3,"sources":["C:/Users/noamc/OneDrive/שולחן העבודה/01 - Northwind Full Stack/02 - Frontend/src/Redux/ProductsState.ts"],"names":["ProductsState","products","ProductsActionType","fetchProductsAction","type","FetchProducts","payload","addProductAction","product","AddProduct","updateProductAction","UpdateProduct","deleteProductAction","id","DeleteProduct","productsReducer","currentState","action","newState","push","indexToUpdate","findIndex","p","indexToDelete","splice"],"mappings":"AAEA;AACA,OAAO,MAAMA,aAAN,CAAoB;AAAA;AAAA,SAChBC,QADgB,GACW,EADX;AAAA;;AAAA,C,CAI3B;;AACA,WAAYC,kBAAZ,C,CAOA;;WAPYA,kB;AAAAA,EAAAA,kB;AAAAA,EAAAA,kB;AAAAA,EAAAA,kB;AAAAA,EAAAA,kB;GAAAA,kB,KAAAA,kB;;AAaZ;AACA,OAAO,SAASC,mBAAT,CAA6BF,QAA7B,EAAuE;AAC1E,SAAO;AAAEG,IAAAA,IAAI,EAAEF,kBAAkB,CAACG,aAA3B;AAA0CC,IAAAA,OAAO,EAAEL;AAAnD,GAAP;AACH;AACD,OAAO,SAASM,gBAAT,CAA0BC,OAA1B,EAAiE;AACpE,SAAO;AAAEJ,IAAAA,IAAI,EAAEF,kBAAkB,CAACO,UAA3B;AAAuCH,IAAAA,OAAO,EAAEE;AAAhD,GAAP;AACH;AACD,OAAO,SAASE,mBAAT,CAA6BF,OAA7B,EAAoE;AACvE,SAAO;AAAEJ,IAAAA,IAAI,EAAEF,kBAAkB,CAACS,aAA3B;AAA0CL,IAAAA,OAAO,EAAEE;AAAnD,GAAP;AACH;AACD,OAAO,SAASI,mBAAT,CAA6BC,EAA7B,EAAyD;AAC5D,SAAO;AAAET,IAAAA,IAAI,EAAEF,kBAAkB,CAACY,aAA3B;AAA0CR,IAAAA,OAAO,EAAEO;AAAnD,GAAP;AACH,C,CAED;AACA;;AACA,OAAO,SAASE,eAAT,GAAoG;AAAA,MAA3EC,YAA2E,uEAA5D,IAAIhB,aAAJ,EAA4D;AAAA,MAAvCiB,MAAuC;AAEvG;AACA,QAAMC,QAAQ,GAAG,EAAE,GAAGF;AAAL,GAAjB;;AAEA,UAAQC,MAAM,CAACb,IAAf;AAEI,SAAKF,kBAAkB,CAACG,aAAxB;AACIa,MAAAA,QAAQ,CAACjB,QAAT,GAAoBgB,MAAM,CAACX,OAA3B,CADJ,CACwC;;AACpC;;AAEJ,SAAKJ,kBAAkB,CAACO,UAAxB;AACIS,MAAAA,QAAQ,CAACjB,QAAT,CAAkBkB,IAAlB,CAAuBF,MAAM,CAACX,OAA9B,EADJ,CAC4C;;AACxC;;AAEJ,SAAKJ,kBAAkB,CAACS,aAAxB;AACI,YAAMS,aAAa,GAAGF,QAAQ,CAACjB,QAAT,CAAkBoB,SAAlB,CAA4BC,CAAC,IAAIA,CAAC,CAACT,EAAF,KAASI,MAAM,CAACX,OAAP,CAAeO,EAAzD,CAAtB,CADJ,CACwF;;AACpF,UAAIO,aAAa,IAAI,CAArB,EAAwB;AACpBF,QAAAA,QAAQ,CAACjB,QAAT,CAAkBmB,aAAlB,IAAmCH,MAAM,CAACX,OAA1C;AACH;;AACD;;AAEJ,SAAKJ,kBAAkB,CAACY,aAAxB;AACI,YAAMS,aAAa,GAAGL,QAAQ,CAACjB,QAAT,CAAkBoB,SAAlB,CAA4BC,CAAC,IAAIA,CAAC,CAACT,EAAF,KAASI,MAAM,CAACX,OAAjD,CAAtB,CADJ,CACqF;;AACjF,UAAIiB,aAAa,IAAI,CAArB,EAAwB;AACpBL,QAAAA,QAAQ,CAACjB,QAAT,CAAkBuB,MAAlB,CAAyBD,aAAzB,EAAwC,CAAxC;AACH;;AACD;AAtBR;;AAyBA,SAAOL,QAAP;AACH","sourcesContent":["import ProductModel from \"../Models/ProductModel\";\r\n\r\n// Products State - products data needed in the application level:\r\nexport class ProductsState {\r\n    public products: ProductModel[] = [];\r\n}\r\n\r\n// Products Action Type - any action which can be done on the above products state:\r\nexport enum ProductsActionType {\r\n    FetchProducts = \"FetchProducts\",\r\n    AddProduct = \"AddProduct\",\r\n    UpdateProduct = \"UpdateProduct\",\r\n    DeleteProduct = \"DeleteProduct\"\r\n}\r\n\r\n// Products Action - any single object sent to the store during \"dispatch\":\r\nexport interface ProductsAction {\r\n    type: ProductsActionType;\r\n    payload: any;\r\n}\r\n\r\n// Products Action Creators - function for creating ProductsAction objects. each function creates one Action object:\r\nexport function fetchProductsAction(products: ProductModel[]): ProductsAction {\r\n    return { type: ProductsActionType.FetchProducts, payload: products };\r\n}\r\nexport function addProductAction(product: ProductModel): ProductsAction {\r\n    return { type: ProductsActionType.AddProduct, payload: product };\r\n}\r\nexport function updateProductAction(product: ProductModel): ProductsAction {\r\n    return { type: ProductsActionType.UpdateProduct, payload: product };\r\n}\r\nexport function deleteProductAction(id: number): ProductsAction {\r\n    return { type: ProductsActionType.DeleteProduct, payload: id };\r\n}\r\n\r\n// Products Reducer - the main function performing any action on products state:\r\n// the new ProductsState() is a default value for the first time only\r\nexport function productsReducer(currentState = new ProductsState(), action: ProductsAction): ProductsState {\r\n\r\n    // Must duplicate the current state and not touch the given current state: \r\n    const newState = { ...currentState };\r\n\r\n    switch (action.type) {\r\n\r\n        case ProductsActionType.FetchProducts:\r\n            newState.products = action.payload; // Here the payload is the products list.\r\n            break;\r\n\r\n        case ProductsActionType.AddProduct:\r\n            newState.products.push(action.payload); // Here the payload is a single object to add.\r\n            break;\r\n\r\n        case ProductsActionType.UpdateProduct:\r\n            const indexToUpdate = newState.products.findIndex(p => p.id === action.payload.id); // Here the payload is a single object to update.\r\n            if (indexToUpdate >= 0) {\r\n                newState.products[indexToUpdate] = action.payload;\r\n            }\r\n            break;\r\n\r\n        case ProductsActionType.DeleteProduct:\r\n            const indexToDelete = newState.products.findIndex(p => p.id === action.payload); // Here the payload is the id to delete.\r\n            if (indexToDelete >= 0) {\r\n                newState.products.splice(indexToDelete, 1);\r\n            }\r\n            break;\r\n    }\r\n\r\n    return newState;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}